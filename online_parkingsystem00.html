// --- データ構造 ---
let parkingRecords = [];
let nextId = 1; // ID自動採番用

// ... (calculateParkingFee 関数と getFormattedDuration 関数は変更なし) ...

/**
 * 駐車時間の表示用フォーマットを計算する
 * @param {string} entryTime - 入庫時刻
 * @param {string | null} exitTime - 出庫時刻
 * @returns {string} フォーマットされた利用時間 (例: "05時間30分" または "利用中")
 */
function getFormattedDuration(entryTime, exitTime) {
    if (!exitTime) return "利用中";

    const entry = new Date(entryTime);
    const exit = new Date(exitTime);
    
    let durationMs = exit - entry;
    if (durationMs < 0) return "エラー";

    const hours = Math.floor(durationMs / (1000 * 60 * 60));
    durationMs -= hours * (1000 * 60 * 60);
    const minutes = Math.floor(durationMs / (1000 * 60));
    
    // XX時間XX分の形式で返す
    return `${String(hours).padStart(2, '0')}時間${String(minutes).padStart(2, '0')}分`;
}

/**
 * 入庫登録処理
 */
function registerEntry() {
    // 確実に入力値を取得
    const plate = document.getElementById('plate-number').value.trim();
    const color = document.getElementById('car-color').value.trim();
    const type = document.getElementById('car-type').value;
    const maker = document.getElementById('car-maker').value;
    
    if (!plate) {
        alert('車両ナンバーは必須です。');
        return;
    }

    // 安定した時刻表現 (ISO 8601)
    const now = new Date().toISOString(); 

    const newRecord = {
        id: nextId++,
        plate: plate,
        entryTime: now,
        exitTime: null,
        carColor: color,
        carType: type,
        carMaker: maker,
        fee: 0,
        status: "入庫" // '入庫', '出庫', '不正駐車'
    };

    parkingRecords.push(newRecord);
    alert(`車両ナンバー ${plate} の入庫を登録しました。ID: ${newRecord.id}`);

    // フォームのリセット
    document.getElementById('plate-number').value = '';
    document.getElementById('car-color').value = '';

    displayLog(); // 履歴表示を更新
}

// ... (processExit 関数は変更なし) ...

/**
 * 履歴テーブルの更新/表示処理
 */
function displayLog() {
    const tbody = document.querySelector('#parking-log-table tbody');
    tbody.innerHTML = ''; // 既存の行をクリア

    // 最新の記録が上に来るように逆順で処理
    parkingRecords.slice().reverse().forEach(record => {
        const row = tbody.insertRow();
        
        // 行のクラス設定（ステータスに応じて色分け）
        row.className = `status-${record.status}`;

        // 利用時間の計算とフォーマット
        const duration = getFormattedDuration(record.entryTime, record.exitTime);
        
        // ローカルタイムに変換して表示
        const entryTimeStr = new Date(record.entryTime).toLocaleTimeString('ja-JP', {hour: '2-digit', minute:'2-digit', second:'2-digit'});
        const exitTimeStr = record.exitTime ? new Date(record.exitTime).toLocaleTimeString('ja-JP', {hour: '2-digit', minute:'2-digit', second:'2-digit'}) : '―';

        // 各セルにデータを挿入
        row.insertCell().textContent = record.id;
        row.insertCell().textContent = record.plate;
        row.insertCell().textContent = entryTimeStr;
        row.insertCell().textContent = exitTimeStr;
        row.insertCell().textContent = duration;
        row.insertCell().textContent = record.fee > 0 ? `${record.fee}円` : '―';
        row.insertCell().textContent = record.status;
        
        // 操作ボタンのセル
        const actionCell = row.insertCell();
        if (record.status === '入庫') {
            const button = document.createElement('button');
            button.textContent = '出庫・清算';
            button.className = 'exit-button';
            button.onclick = () => processExit(record.id);
            actionCell.appendChild(button);
        } else {
            actionCell.textContent = '完了';
        }
    });
}

// ページロード時に一度表示を初期化
// ※ 前回のコードではこれを行っていました。DOMContentLoadedイベントの場所を気にせず、ボタンがクリックされたら必ずdisplayLog()が走るため、この初期化は必須ではありませんが、残しておきます。
document.addEventListener('DOMContentLoaded', displayLog);